#!/usr/bin/perl
#
# Generated by Chef for <%= node[:fqdn] %>
#
# Any local changes will be deleted.
#
# Copyright 2013, Edmunds.com
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

use warnings;
use strict;
use Data::Dumper;
use Getopt::Std;

my $connections = ();
my @netstat = `netstat -tn`;
my @netstat_listening = `netstat -ltn`;
my %listening_ports_h;
my @listening_ports;
my $connections_file = "/var/log/connections/connections.txt";
my $date = `date +"%d%b%Y%H%M"`; chomp $date;
my $max_entries = 50;
my $max_count = 50000; # arbitrary ceiling used to trigger scale-down of count values
my $expiration = 86400; # one day of seconds
my %options=();
my $now = time;

# input file, max entries, and expiration of entries based on seconds since last observed
getopts("i:m:x:c:",\%options);
if ( defined $options{i} ) { $connections_file = $options{i}; }
if ( defined $options{m} ) { $max_entries = $options{m}; }
if ( defined $options{x} ) { $expiration = $options{x}; }
if ( defined $options{c} ) { $max_count = $options{c}; }
#print "Connections file: $connections_file\n";
#print "Max entries:  $max_entries\n";
#print "Expiration:  $expiration\n";
#print "Max count:  $max_count\n";

# Gather all of the listening ports - we'll use these to determine connection directionality where possible
foreach ( @netstat_listening ) {
  if ( m/^Active/ or m/^Proto/ ){ next; }
  #print "Checking listening ports: $_";
  ( my $proto, my $recvq, my $sendq, my $localaddress, my $foreignaddress, my $state ) = split;
  if ($proto eq "tcp" or $proto eq "udp") {
    my $local_ip, my $listen_port;
    if ( $localaddress =~ m/^::ffff:/ ){
      $localaddress =~ s/^::ffff://;
    }
    unless ( $localaddress =~ m/^127.0.0.1/ ){
      if ( $localaddress =~ m/^:::/ ){
        $localaddress =~ s/^::://;
	$local_ip = "0.0.0.0"; 
	$listen_port = $localaddress;
      }	
      else {
        ( $local_ip, $listen_port ) = split (':', $localaddress);
      }
      $listening_ports_h{$listen_port} = 1;
    }
  }
}
@listening_ports = keys %listening_ports_h;
#print "listening keys: ";
#foreach ( @listening_ports ) { print $_ . "\t"; }
#print "\n";

# Pull in connections database 
if ( -e $connections_file ){
  open( CONNECTIONS, "< $connections_file" ) or die "Can't open $connections_file : $!";
  while ( <CONNECTIONS> ) {
    unless ( m/^LOCALIP/ or m/^$/ ) {
      #print "Loading database - about to operate on: $_";
      ( my $local_ip, my $local_listen_port, my $foreign_ip, my $remote_port, my $protocol, my $count, my $lastseen, my $before ) = split;
      if ( defined $local_ip and defined $local_listen_port and defined $foreign_ip and defined $remote_port and defined $protocol and defined $count and defined $lastseen and defined $before ){
	#print "$now - $before gt $expiration ?\n";
	#my $diff = $now-$before;
	#print "Diff is $diff\n";
	unless ( ($now-$before) > $expiration ) {
	  #print "Reading in entry for $foreign_ip\n";
	  $connections->{$foreign_ip} = {
	    local_ip => $local_ip,
	    foreign_ip => $foreign_ip,
	    local_listen_port => $local_listen_port,
	    remote_port => $remote_port,
	    protocol => $protocol,
	    count => $count,
	    last_seen => $lastseen,
	    last_seen_epoch => $before,
	  };
	}
      }
    }
  }
  close ( CONNECTIONS );
  #print Dumper($connections);
}

# Gather all of the connections and build a hash
foreach ( @netstat ) {
  if ( m/^Active/ or m/^Proto/ ){ next; }
  #print "Checking connections, each is: $_";
  ( my $proto, my $recvq, my $sendq, my $localaddress, my $foreignaddress, my $state ) = split;
  if ($proto eq "tcp") {
    $foreignaddress =~ s/::ffff://;
    $localaddress =~ s/::ffff://;
    #print "foreignaddress is $foreignaddress\n";
    #print "localaddress is $localaddress\n";
    # Split based on port
    ( my $foreign_ip, my $foreign_port ) = split(/:/, $foreignaddress);
    ( my $local_ip, my $local_port ) = split(/:/, $localaddress);
    unless ( $foreignaddress =~ m/localhost/ or $foreignaddress =~ m/127.0.0.1/){
      if ( exists $connections->{$foreign_ip} ) {
        # Update the time stamp and increment the count
        $connections->{$foreign_ip}->{count} = $connections->{$foreign_ip}->{count}+1;
        $connections->{$foreign_ip}->{last_seen} = $date;
        $connections->{$foreign_ip}->{last_seen_epoch} = $now;
      }
      else {
        my $local_listen_port, my $remote_port;
        if ( exists $listening_ports_h{$local_port} ) {
          $local_listen_port = $local_port;
          $remote_port = "NA";
        }
        else {
          $remote_port = $foreign_port;
          $local_listen_port = "NA";
        }
        $connections->{$foreign_ip} = {
          local_ip => $local_ip,
          foreign_ip => $foreign_ip,
          local_listen_port => $local_listen_port,
          remote_port => $remote_port,
          protocol => $proto,
          count => 1,
          last_seen => $date,
          last_seen_epoch => $now,
        };
      }
    }
  }
}

#print Dumper($connections);
#print scalar keys %$connections;

# Write out the connections database 
open( CONNECTIONS, "> $connections_file" ) or die "Can't open $connections_file : $!";
print CONNECTIONS "LOCALIP\tLOCALLISTENPORT\tFOREIGNIP\tREMOTEPORT\tPROTOCOL\tCOUNT\tLASTSEEN\tEPOCHTIME\n";

my $elem, my $count = 0;
my $divisor = 1;  # used for count scale-down - has no effect by default

# See if the counts for the connections have exceeded the max_count ceiling
# If so, set a divisor to 2 so that the counts can be scaled down when saved
foreach $elem ( reverse sort { $a->{'count'} <=> $b->{'count'} } values %{$connections} ) {
  if ( $elem->{count} >= $max_count ) { 
    $divisor = 2;
    last; 
  }
}

# Write out the connections, but only $max_entries worth
# Also, scale down the count if needed
foreach $elem ( reverse sort { $a->{'count'} <=> $b->{'count'} } values %{$connections} ) {
  if ( $count >= $max_entries ) { last; }
  # If we're going to be scaling down, increment any 1-count connections to prevent their loss due to integer rounding
  if ( $divisor > 1 and $elem->{count} <= 1 ) { $elem->{count}++; } 
  print CONNECTIONS $elem->{local_ip}."\t".$elem->{local_listen_port}."\t".$elem->{foreign_ip}."\t".$elem->{remote_port}."\t".$elem->{protocol}."\t".int($elem->{count}/$divisor)."\t".$elem->{last_seen}."\t".$elem->{last_seen_epoch}."\n";
  $count++;
}
close ( CONNECTIONS );
